#!/usr/bin/env python
from JumpScale import j
from JumpScale.baselib import cmdutils

import sys,time

j.application.start("jstest")

parser = cmdutils.ArgumentParser()
parser.add_argument("action", choices=['commit','push','update','status'], help='Command to perform')

parser.add_argument('-m','--message',help='commit message')
parser.add_argument('-b','--branch',help='branch')

parser.add_argument('-a','--accounts',help='comma separated list of accounts')
parser.add_argument('-r','--repos',help='comma separated list of repos, will look for the accounts')

parser.add_argument('-u','--update',required=False, action='store_true',help='update merge before doing push or commit')

parser.add_argument('-f','--force',required=False, action='store_true',help='auto answer yes on every question')


# parser.add_argument('-m','--message',required=False, action='store_true',help='commit message')

opts = parser.parse_args()

if opts.accounts==None and opts.repos==None:
    if j.system.fs.exists("%s/%s"%(j.system.fs.getcwd(),".hg")):
        #we are in repo
        opts.repos=j.system.fs.getBaseName(j.system.fs.getcwd())
        opts.accounts=j.system.fs.getBaseName(j.system.fs.getParent(j.system.fs.getcwd()))

if opts.branch<>None and opts.action in ['status']: 
    raise RuntimeError("Cannot specify branch when asking status")

def getRepos():
    result=[]
    if opts.accounts<>None:
        accounts=[item.strip() for item in opts.accounts.split(",")]
    elif opts.repos<>None:
        accounts=j.system.fs.listDirsInDir("/opt/code", recursive=False, dirNameOnly=True, findDirectorySymlinks=True)
    else:
        accounts=j.system.fs.listDirsInDir("/opt/code", recursive=False, dirNameOnly=True, findDirectorySymlinks=True)
        accounts=j.console.askChoiceMultiple(accounts,"select bitbucketaccounts")

    for account in accounts:
        accountdir="/opt/code/%s"%account
        if j.system.fs.exists(accountdir):
            bitbucket=j.clients.bitbucket.getBitbucketAccountClient(account)
            if opts.repos==None:
                reponames=j.system.fs.listDirsInDir(accountdir,recursive=False, dirNameOnly=True, findDirectorySymlinks=True)
                if  not opts.action in ['status']:
                    reponames=j.console.askChoiceMultiple(reponames,"select repos")
            else:
                reponames=[item.strip() for item in opts.repos.split(",")]

            for reponame in reponames:
                repodir="%s/%s"%(accountdir,reponame)
                if not j.system.fs.exists(path=repodir):
                    raise RuntimeError("Could not find mercurial repo on %s"%repodir)
                cl=bitbucket.getMercurialClient(reponame)
                # cl=j.clients.mercurial.getClient(item)
                result.append((bitbucket,account,reponame,cl,repodir))
    return result


repos=getRepos()

if opts.action == "status":
    print "\n\nSTATUS: account reponame branch added:modified:deleted needapush localrev remoterev"
    print "==================================================================================="


for bitbucket,account,reponame,client,path in repos:

    if opts.action in ['status','commit','push','update']:

        mods=client.getModifiedFiles()

        lrev,lid,ttype,branch,user,msg,ddate=client.client.tip()
        client.branchname
        changesets=bitbucket.getChangeSets(reponame=reponame,limit=1)
        if changesets.has_key("error"):
            print "could not process repo: %s %s error:%s"%(account,reponame,changesets["error"]["message"])
            # print changesets            
            continue
        try:
            remotelastrevision=changesets["changesets"][0]["revision"]
        except Exception,e:
            from IPython import embed
            print "DEBUG NOW jscode check error from changeset pull"
            embed()
            
        rid=changesets["changesets"][0]["raw_node"] #remoteid

        if lid==rid:
            reposync="Y"
        else:
            reposync="N"

        nrmods= len(mods["added"])+len(mods["nottracked"])+len(mods["modified"])+len(mods["missing"])+len(mods["removed"])

        print "%-15s %-25s %-10s a%-3s:m%-3s:d%-3s reposync:%-1s  lrev:%-5s rrev:%-5s" %(account,reponame,client.branchname,\
            len(mods["added"])+len(mods["nottracked"]),len(mods["modified"]),len(mods["missing"])+len(mods["removed"]),\
            reposync,\
            lrev,remotelastrevision)

    if opts.action in ['push']:
        if nrmods==0 and reposync=="Y":
            print "no need to push, repo is in sync"
            continue

    if opts.action in ['update']:
        if nrmods==0 and reposync=="Y":
            print "no need to update, repo is in sync"
            continue

    if opts.action in ['commit']:
        if nrmods==0:
            print "no need to commit, no mods"
            continue

    if opts.action in ['commit','push','update']:

        if opts.message==None and nrmods>0:
            opts.message=j.console.askString("commit message")

        if opts.branch<>None:
            cmd="cd %s;hg branch %s"%(path,opts.branch)
            print "branch:%s"%opts.branch

    if opts.update or opts.action =='update':
        print "PULL ",
        client.pull()
        print "UPDATE ",
        client.updatemerge(commitMessage=opts.message, ignorechanges=False,
            addRemoveUntrackedFiles=True, trymerge=True, pull=False,force=opts.force)        
    
    if opts.action =='commit' or opts.action =='push':
        print "COMMIT ",
        client.commit(message=opts.message, addremove=True, checkStatus=True, force=False)

        if opts.action =='push':
            print "PUSH ",
            if opts.branch<>None:
                client.push(branch=[opts.branch],newbranch=True)
            else:
                client.push(branch=None,newbranch=False)

    if opts.action in ['commit','push','update']:
        print




j.application.stop()
