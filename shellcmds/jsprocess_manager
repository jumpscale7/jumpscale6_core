#!/usr/bin/env python
from JumpScale import j

import JumpScale.grid.geventws
import gevent
from gevent.event import Event
# import JumpScale.baselib.statmanager
import JumpScale.baselib.graphite
import psutil

import JumpScale.baselib.stataggregator

j.application.start("jsprocess_manager")

j.logger.consoleloglevel = 5

class MgrCmds():

    def __init__(self, daemon):
        self.daemon = daemon
        self.manager=j.tools.startupmanager        
        self.monitorProcess()
        self.lastMonitorResult=None
        self.lastMonitorTime=None
        self.aggregator=j.system.stataggregator

    def authenticate(self, user, login, **args):
        return True  # will authenticall all (is std)

    # def reset(self, **args):
    #     return self.manager.reset()

    def getDomains(self,**args):
        return self.manager.getDomains()

    def startJPackage(self,jpackage,timeout=20,**args):
        return self.manager.startJPackage(jpackage,timeout)

    def stopJPackage(self,jpackage,timeout=20,**args):        
        return self.manager.stopJPackage(jpackage,timeout)

    def existsJPackage(self,jpackage,**args):
        return self.manager.existsJPackage(jpackage)

    def startAll(self,**args):
        return self.manager.startAll()

    def removeProcess(self,domain, name,**args):
        return self.manager.removeProcess(domain, name)

    def getStatus4JPackage(self,jpackage,**args):
        return self.manager.getStatus4JPackage(jpackage)

    def getStatus(self, domain, name,**args):
        """
        get status of process, True if status ok
        """
        return self.manager.getStatus( domain, name)

    def listProcesses(self,**args):
        return [item.split("__") for item in self.manager.listProcesses()]

    def getProcessesActive(self, domain=None, name=None, **kwargs):
        result = list()
        for pd in self.manager.getProcessDefs(domain, name):
            item = dict()
            item['status'] = pd.isRunning()
            item['pid'] = pd.pid
            item['name'] = pd.name
            item['domain'] = pd.domain
            item['autostart'] = pd.autostart == '1'
            item['cmd'] = pd.cmd
            item['args'] = pd.args
            item['args'] = pd.args
            item['ports'] = pd.ports
            item['priority'] = pd.priority
            item['workingdir'] = pd.workingdir
            item['env'] = pd.env
            result.append(item)
        return result


    def startProcess(self, domain="", name="", timeout=20,**args):
        return self.manager.startProcess( domain, name, timeout)

    def stopProcess(self, domain,name, timeout=20,**args):
        return self.manager.stopProcess(domain,name, timeout)

    def disableProcess(self, domain,name, timeout=20,**args):
        return self.manager.disableProcess( domain,name, timeout)

    def enableProcess(self, domain,name, timeout=20,**args):
        return self.manager.enableProcess( domain,name, timeout)

    def monitorProcess(self, domain="",name="",remember=False,**args):
        results={}
        for pd in self.manager.getProcessDefs(domain,name):
            t=pd.getStatInfo()
            t2={}
            for key in t.keys():
                results["processes.%s.%s.%s"%(pd.domain,pd.name,key)]=t[key]

        result2={}
        for key in results.keys():
            result2[key]=j.system.stataggregator.set(key,results[key],remember=remember)

        return result2


    def monitorSystem(self,remember=False,session=None):
        
        results={}
        nr=0
        for val in psutil.cpu_percent(0,True):
            nr+=1
            results["cpu.percent.%s"%nr]=round(val,0)

        nr=0
        for cput in psutil.cpu_times(True):
            nr+=1
            for key in cput.__dict__.keys():
                val=cput.__dict__[key]
                results["cpu.time.%s.%s"%(key,nr)]=val

        #disk counters
        counters=psutil.disk_io_counters(True)
        nr=0
        for counterkey in counters.keys():
            counter=counters[counterkey]
            nr+=1
            read_count, write_count, read_bytes, write_bytes, read_time, write_time=counter
            results["disk.time.read.%s"%(counterkey)]=read_time
            results["disk.time.write.%s"%(counterkey)]=write_time
            results["disk.count.read.%s"%(counterkey)]=read_count
            results["disk.count.write.%s"%(counterkey)]=write_count
            results["disk.mbytes.read.%s"%(counterkey)]=round(read_bytes/1024/1024,2)
            results["disk.mbytes.write.%s"%(counterkey)]=round(write_bytes/1024/1024,2)

        #network counters
        counters=psutil.network_io_counters(True)
        nr=0
        for counterkey in counters.keys():
            counter=counters[counterkey]
            nr+=1
            bytes_sent, bytes_recv, packets_sent, packets_recv, errin, errout, dropin, dropout=counter
            results["network.kbytes.recv.%s"%(counterkey)]=round(bytes_recv/1024,0)
            results["network.kbytes.send.%s"%(counterkey)]=round(bytes_sent/1024,0)
            results["network.packets.recv.%s"%(counterkey)]=packets_recv
            results["network.packets.send.%s"%(counterkey)]=packets_sent
            results["network.error.in.%s"%(counterkey)]=errin
            results["network.error.out.%s"%(counterkey)]=errout
            results["network.drop.in.%s"%(counterkey)]=dropin
            results["network.drop.out.%s"%(counterkey)]=dropout

        #disk freespace
        for part in psutil.disk_partitions():
            total,used,free,percent=psutil.disk_usage(part.mountpoint)
            results["disk.space.free.%s"%(part.device)]=round(free/1024/1024,2)
            results["disk.space.used.%s"%(part.device)]=round(used/1024/1024,2)
            results["disk.space.percent.%s"%(part.device)]=percent

        total,used,free,percent=psutil.phymem_usage()
        results["memory.free"]=round(free/1024/1024,2)
        results["memory.used"]=round(used/1024/1024,2)
        results["memory.percent"]=percent

        total,used,free,percent,sin,sout=psutil.virtmem_usage()
        results["swap.free"]=round(free/1024/1024,2)
        results["swap.used"]=round(used/1024/1024,2)
        results["swap.percent"]=percent

        result2={}
        for key in results.keys():
            result2[key]=j.system.stataggregator.set(key,results[key],remember=remember)

        return result2


        # out=""
        # keys=result.keys()
        # keys.sort()
        # for key in keys:
        #     out+="%s.%s %s\n"%(jspid,key,result[key])


        # j.system.statmanager.addInfo(monitorinfo)

    def restartProcess(self, domain,name,**args):
        return self.manager.restartProcess( domain,name)

    def reloadProcess(self, domain, name,**args):
        return self.manager.reloadProcess( domain,name)



    def _loop120(self):
        """
        loop 120 sec
        """

        while True:
            self.startProcess()
            j.system.stataggregator.send2carbon()
            gevent.sleep(12) #change to 120

    def _loop30(self):
        """
        loop 30 sec
        """

        while True:
            self.monitorSystem(remember=True)
            self.monitorProcess(remember=True)
            gevent.sleep(30)

    def _loopClean(self):
        """
        loop 0.5h 
        """
        while True:            
            gevent.sleep(1800)
            self.aggregator.clean()

    def _timer(self):
        """
        loop 0.5 sec
        """

        while True:
            j.system.stataggregator.now=time.time()
            gevent.sleep(0.5)

daemon = j.servers.geventws.getServer(port=4445)

daemon.addCMDsInterface(MgrCmds, category="processmanager")  # pass as class not as object !!! chose category if only 1 then can leave ""

cmds=daemon.daemon.cmdsInterfaces["processmanager"][0]

# daemon.startClock()

# daemon.schedule("loop5",cmds.loop)
daemon.schedule("loop120",cmds._loop120) #startupmg
daemon.schedule("loop30",cmds._loop30)
daemon.schedule("loopClean",cmds._loopClean)


# daemon.schedule("timer",cmds.timer)

daemon.start()

j.application.stop()
